<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Spring-Mass-Damper Simulation</title>
  <style>
    :root {
      --ui-w: 320px;
      --gap: 10px;
      --bg: #0e0f12;
      --card: #111316;
      --accent: #6ee7b7;
      --muted: #9aa4ad;
    }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#071026 0%, #0e0f12 100%);color:#e6eef3}
    .wrap{display:flex;gap:var(--gap);padding:20px;max-width:1200px;margin:0 auto;align-items:flex-start}
    .sim {
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.005));
      border:1px solid rgba(255,255,255,0.03);
      border-radius:12px;
      padding:14px;
      flex:1;
      min-height:520px;
    }
    canvas{display:block;width:100%;height:520px;border-radius:8px;background:linear-gradient(180deg,#052033 0%, #071226 100%);}
    .ui {
      width:var(--ui-w);
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    .card {
      background:var(--card);
      border-radius:10px;
      padding:12px;
      border:1px solid rgba(255,255,255,0.03);
    }
    label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
    .row {display:flex;gap:8px;align-items:center}
    input[type=range]{width:100%}
    .value {min-width:64px;text-align:right;font-variant-numeric:tabular-nums}
    button{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:var(--accent);cursor:pointer}
    select,input[type=number]{background:#0b0d10;border:1px solid rgba(255,255,255,0.03);color:#e6eef3;padding:6px;border-radius:6px}
    .small{font-size:13px;color:var(--muted)}
    .controls-grid{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center}
    .footer-note{font-size:12px;color:var(--muted);margin-top:6px}
    .numeric-readout{font-family:monospace;font-size:13px;color:#dff9ea}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="sim card">
      <canvas id="c" width="800" height="520"></canvas>
      <div style="display:flex;justify-content:space-between;gap:8px;margin-top:10px">
        <div class="small numeric-readout">x = <span id="xr">0.000</span> m</div>
        <div class="small numeric-readout">v = <span id="vr">0.000</span> m/s</div>
        <div class="small numeric-readout">E ≈ <span id="er">0.000</span> J</div>
      </div>
    </div>

    <div class="ui">
      <div class="card">
        <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
          <strong>Controls</strong>
          <div style="display:flex;gap:6px">
            <button id="playPause">Pause</button>
            <button id="reset">Reset</button>
          </div>
        </div>
        <div style="margin-top:8px" class="small">Integrator:
          <select id="integrator">
            <option value="semi">Semi-implicit Euler (fast & stable)</option>
            <option value="rk4">RK4 (more accurate)</option>
          </select>
        </div>
      </div>

      <div class="card">
        <label>Mass (kg)</label>
        <div class="controls-grid">
          <input id="m" type="range" min="0.1" max="10" step="0.1" value="1">
          <input id="mVal" type="number" min="0.1" max="10" step="0.1" value="1">
        </div>

        <label style="margin-top:8px">Spring constant k (N/m)</label>
        <div class="controls-grid">
          <input id="k" type="range" min="1" max="500" step="1" value="60">
          <input id="kVal" type="number" min="1" max="500" step="1" value="60">
        </div>

        <label style="margin-top:8px">Damping c (N·s/m)</label>
        <div class="controls-grid">
          <input id="c" type="range" min="0" max="50" step="0.1" value="2">
          <input id="cVal" type="number" min="0" max="50" step="0.1" value="2">
        </div>

        <label style="margin-top:8px">Gravity (m/s²)</label>
        <div class="controls-grid">
          <input id="g" type="range" min="-20" max="20" step="0.1" value="9.81">
          <input id="gVal" type="number" min="-20" max="20" step="0.1" value="9.81">
        </div>

        <label style="margin-top:8px">Rest length (px for drawing) — visual</label>
        <div class="controls-grid">
          <input id="rest" type="range" min="40" max="300" step="1" value="180">
          <input id="restVal" type="number" min="40" max="300" step="1" value="180">
        </div>

        <div class="footer-note">Drag the mass with the mouse/touch to set position. Values are in SI units (meters, kg, N/m, m/s²) for the physics; drawing uses pixels.</div>
      </div>

      <div class="card">
        <strong>Initial state</strong>
        <div style="margin-top:8px">
          <label>Initial displacement (m)</label>
          <input id="x0" type="number" step="0.01" value="0.5" style="width:100%">
          <label style="margin-top:8px">Initial velocity (m/s)</label>
          <input id="v0" type="number" step="0.01" value="0.0" style="width:100%">
        </div>
      </div>

      <div class="card">
        <strong>Tips</strong>
        <ul style="margin:8px 0 0 18px;padding:0;color:var(--muted)">
          <li>Higher damping → faster decay.</li>
          <li>RK4 better for large time steps; semi-implicit is cheap and stable for real-time.</li>
          <li>Use small dt (fixed step) for accuracy; code uses a fixed physics step internally.</li>
        </ul>
      </div>
    </div>
  </div>

<script>
/*
  Spring-mass-damper simulation
  m * a = -k * x - c * v + m * g
  state variable: x (displacement from equilibrium), v (velocity)
  This example keeps drawing/visual units separate from physics meters; consider 1 m = 100 px mapping.
*/

(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  // UI elements
  const playPauseBtn = document.getElementById('playPause');
  const resetBtn = document.getElementById('reset');
  const integratorSelect = document.getElementById('integrator');

  const mRange = document.getElementById('m'), mVal = document.getElementById('mVal');
  const kRange = document.getElementById('k'), kVal = document.getElementById('kVal');
  const cRange = document.getElementById('c'), cVal = document.getElementById('cVal');
  const gRange = document.getElementById('g'), gVal = document.getElementById('gVal');
  const restRange = document.getElementById('rest'), restVal = document.getElementById('restVal');

  const x0Input = document.getElementById('x0'), v0Input = document.getElementById('v0');

  const xr = document.getElementById('xr'), vr = document.getElementById('vr'), er = document.getElementById('er');

  // Simulation parameters (physics units: meters, kg, N/m)
  let params = {
    m: parseFloat(mRange.value),
    k: parseFloat(kRange.value),
    c: parseFloat(cRange.value),
    g: parseFloat(gRange.value)
  };

  // Visual mapping: meters -> pixels
  const metersToPx = 120; // 1 m => 120 px for drawing
  const anchorX = 200; // px
  let anchorY = 60; // px (top anchor point for spring)

  // State (x: displacement from equilibrium position in meters; v: m/s)
  let state = {
    x: parseFloat(x0Input.value), // meters (positive: mass below rest)
    v: parseFloat(v0Input.value)
  };

  // Visual rest length (px) stored separately
  let restLengthPx = parseFloat(restRange.value);

  // Animation control
  let running = true;
  let lastTime = performance.now();
  let accumulator = 0;
  const physicsDt = 1 / 240; // fixed physics step in seconds (small and stable)

  // Safeguard: cap accumulator to avoid spiral-of-death on tab switching
  const maxAccumulator = 0.2;

  // Canvas sizing (handle devicePixelRatio)
  function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const styleW = canvas.clientWidth || canvas.width;
    const styleH = canvas.clientHeight || canvas.height;
    canvas.width = Math.round(styleW * dpr);
    canvas.height = Math.round(styleH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // --- Physics functions ---
  function acceleration(x, v, p) {
    // Hooke's law + damping + gravity (gravity acts downward = positive)
    // Note: x measured relative to equilibrium (we treat equilibrium at x=0)
    // F_spring = -k * x, F_damping = -c * v, F_gravity = m * g
    return (-p.k * x - p.c * v + p.m * p.g) / p.m;
  }

  // Semi-implicit Euler (symplectic-ish for simple systems; stable)
  function stepSemiImplicit(state, dt, p) {
    const a = acceleration(state.x, state.v, p);
    state.v += a * dt;
    state.x += state.v * dt;
  }

  // RK4 integrator for accuracy
  function stepRK4(state, dt, p) {
    // derivative: dx/dt = v, dv/dt = a(x,v)
    const k1 = { dx: state.v, dv: acceleration(state.x, state.v, p) };

    const x2 = state.x + 0.5 * dt * k1.dx;
    const v2 = state.v + 0.5 * dt * k1.dv;
    const k2 = { dx: v2, dv: acceleration(x2, v2, p) };

    const x3 = state.x + 0.5 * dt * k2.dx;
    const v3 = state.v + 0.5 * dt * k2.dv;
    const k3 = { dx: v3, dv: acceleration(x3, v3, p) };

    const x4 = state.x + dt * k3.dx;
    const v4 = state.v + dt * k3.dv;
    const k4 = { dx: v4, dv: acceleration(x4, v4, p) };

    state.x += (dt / 6) * (k1.dx + 2 * k2.dx + 2 * k3.dx + k4.dx);
    state.v += (dt / 6) * (k1.dv + 2 * k2.dv + 2 * k3.dv + k4.dv);
  }

  // Energy estimate (useful readout): E = 1/2 m v^2 + 1/2 k x^2 + m g y
  // We'll compute gravitational potential relative to x=0: m*g*(x)
  function energy(state, p) {
    const ke = 0.5 * p.m * state.v * state.v;
    const pe = 0.5 * p.k * state.x * state.x;
    const grav = p.m * p.g * state.x;
    return ke + pe + grav;
  }

  // --- Drawing ---
  function drawSpring(ctx, x1, y1, x2, y2, coils=12, amplitude=12) {
    // draw a spring between (x1,y1) and (x2,y2) using a polyline
    const dx = x2 - x1;
    const dy = y2 - y1;
    const len = Math.hypot(dx, dy);
    if (len < 1) {
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); return;
    }
    const nx = dx / len, ny = dy / len;
    const tx = -ny, ty = nx; // tangent for coil offset
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    const segments = coils * 2;
    for (let i=1;i<=segments;i++) {
      const t = i / segments;
      const cx = x1 + nx * (t * len);
      const cy = y1 + ny * (t * len);
      const sign = (i % 2 === 0) ? 1 : -1;
      const off = amplitude * sign * (1 - Math.abs(2*t-1)); // taper amplitude slightly
      ctx.lineTo(cx + tx * off, cy + ty * off);
    }
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }

  function render() {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    ctx.clearRect(0, 0, w, h);

    // Background grid / anchor indicator
    ctx.fillStyle = '#071226';
    ctx.fillRect(0,0,w,h);

    // anchor point
    const ax = anchorX, ay = anchorY;
    ctx.fillStyle = '#7be7c7';
    ctx.beginPath(); ctx.arc(ax, ay, 6, 0, Math.PI*2); ctx.fill();

    // compute mass position for drawing: equilibrium (x=0) corresponds to restLengthPx
    // We'll map state.x (meters) onto pixels
    const massY = ay + restLengthPx + state.x * metersToPx;
    const massX = anchorX;

    // spring
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#89f0c9';
    drawSpring(ctx, ax, ay, massX, massY, 12, 10);

    // damper or decoration could be drawn here

    // mass block
    const mx = massX - 28, my = massY - 18, mw = 56, mh = 36;
    ctx.fillStyle = '#0a8f6c';
    ctx.fillRect(mx, my, mw, mh);
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.strokeRect(mx, my, mw, mh);
    ctx.fillStyle = '#e6f8ee';
    ctx.font = '14px monospace';
    ctx.textAlign = 'center';
    ctx.fillText((state.x).toFixed(2) + ' m', massX, massY + 35);

    // small labels
    ctx.fillStyle = 'rgba(255,255,255,0.07)';
    ctx.font = '12px Arial';
    ctx.fillText('anchor', ax + 40, ay + 4);

    // update numeric UI
    xr.textContent = state.x.toFixed(3);
    vr.textContent = state.v.toFixed(3);
    er.textContent = energy(state, params).toFixed(3);
  }

  // --- Main loop ---
  function updatePhysics(dt) {
    // call the chosen integrator with a fixed dt
    const integrator = integratorSelect.value;
    if (integrator === 'rk4') stepRK4(state, dt, params);
    else stepSemiImplicit(state, dt, params);
  }

  function loop(now) {
    if (!running) { lastTime = now; requestAnimationFrame(loop); render(); return; }
    let frameDt = (now - lastTime) / 1000;
    lastTime = now;
    // clamp very large frames
    if (frameDt > 0.25) frameDt = 0.25;
    accumulator += frameDt;
    if (accumulator > maxAccumulator) accumulator = maxAccumulator;
    while (accumulator >= physicsDt) {
      updatePhysics(physicsDt);
      accumulator -= physicsDt;
    }
    render();
    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);

  // --- UI wiring ---
  function syncRangeToNumber(range, number) {
    range.addEventListener('input', () => {
      number.value = range.value;
      params.m = parseFloat(mRange.value);
    });
  }
  // mass
  mRange.addEventListener('input', () => { mVal.value = mRange.value; params.m = parseFloat(mRange.value); });
  mVal.addEventListener('change', () => { mRange.value = mVal.value; params.m = parseFloat(mVal.value); });

  // k
  kRange.addEventListener('input', () => { kVal.value = kRange.value; params.k = parseFloat(kRange.value); });
  kVal.addEventListener('change', () => { kRange.value = kVal.value; params.k = parseFloat(kVal.value); });

  // c
  cRange.addEventListener('input', () => { cVal.value = cRange.value; params.c = parseFloat(cRange.value); });
  cVal.addEventListener('change', () => { cRange.value = cVal.value; params.c = parseFloat(cVal.value); });

  // g
  gRange.addEventListener('input', () => { gVal.value = gRange.value; params.g = parseFloat(gRange.value); });
  gVal.addEventListener('change', () => { gRange.value = gVal.value; params.g = parseFloat(gVal.value); });

  // rest length (visual only)
  restRange.addEventListener('input', () => { restVal.value = restRange.value; restLengthPx = parseFloat(restRange.value); });
  restVal.addEventListener('change', () => { restRange.value = restVal.value; restLengthPx = parseFloat(restVal.value); });

  // initial state
  resetBtn.addEventListener('click', () => {
    state.x = parseFloat(x0Input.value) || 0;
    state.v = parseFloat(v0Input.value) || 0;
  });

  playPauseBtn.addEventListener('click', () => {
    running = !running;
    playPauseBtn.textContent = running ? 'Pause' : 'Play';
  });

  // clicking and dragging the mass to set x
  let dragging = false;
  function getPointerPos(e) {
    const rect = canvas.getBoundingClientRect();
    if (e.touches && e.touches[0]) {
      return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
    }
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
  }

  function pointerDown(e) {
    const p = getPointerPos(e);
    const massY = anchorY + restLengthPx + state.x * metersToPx;
    const massX = anchorX;
    // hit-test on mass area
    if (Math.abs(p.x - massX) < 60 && Math.abs(p.y - massY) < 40) {
      dragging = true;
      running = false; // pause while dragging
      playPauseBtn.textContent = 'Play';
      e.preventDefault();
    }
  }
  function pointerMove(e) {
    if (!dragging) return;
    const p = getPointerPos(e);
    const dy = p.y - (anchorY + restLengthPx); // pixels below rest anchor
    state.x = dy / metersToPx; // convert back to meters
    state.v = 0; // reset velocity (or compute from drag delta if you want)
  }
  function pointerUp(e) {
    if (dragging) {
      dragging = false;
    }
  }

  canvas.addEventListener('mousedown', pointerDown);
  window.addEventListener('mousemove', pointerMove);
  window.addEventListener('mouseup', pointerUp);

  // touch
  canvas.addEventListener('touchstart', pointerDown, {passive:false});
  window.addEventListener('touchmove', pointerMove, {passive:false});
  window.addEventListener('touchend', pointerUp);

  // initial setup: set params and UI values
  params.m = parseFloat(mRange.value);
  params.k = parseFloat(kRange.value);
  params.c = parseFloat(cRange.value);
  params.g = parseFloat(gRange.value);
  restLengthPx = parseFloat(restRange.value);

  // set initial state from inputs
  state.x = parseFloat(x0Input.value) || 0;
  state.v = parseFloat(v0Input.value) || 0;

  // Make sure canvas sized correctly after fonts load
  window.addEventListener('load', () => {
    resizeCanvas();
  });

})();
</script>
</body>
</html>
